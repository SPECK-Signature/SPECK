

# This file was *autogenerated* from the file arrangements.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_1p = RealNumber('1.'); _sage_const_127 = Integer(127); _sage_const_252 = Integer(252); _sage_const_126 = Integer(126); _sage_const_64 = Integer(64)
from collections import Counter
from sage.all_cmdline import Combinations, Permutations, Arrangements
from math import comb
import random

def multiplicities(mset: list):
    sorted_mset = sorted(mset)
    cnt = [_sage_const_0  for _ in list(set(sorted_mset))]
    current_elem = sorted_mset[_sage_const_0 ]
    current_index = _sage_const_0 
    for i in range(_sage_const_0 ,len(sorted_mset)):
        if sorted_mset[i] != current_elem:
            current_index += _sage_const_1 
            current_elem = sorted_mset[i]
        cnt[current_index] += _sage_const_1 
    return cnt

def arrangements_mset_max_k(mset: list, k: int):
    cnt = multiplicities(mset)

    nrs = [_sage_const_0  for _ in range(k+_sage_const_1 )]
    nrs[_sage_const_0 ]=_sage_const_1 

    for n in range(_sage_const_0 ,len(cnt)):
        for l in range(k,_sage_const_0 ,-_sage_const_1 ):
            nr = _sage_const_0 
            bino = _sage_const_1 
            for i in range(min(cnt[n],l)+_sage_const_1 ):
                nr = nr + bino*nrs[l-i]
                bino = int(bino * (l-i)/(i+_sage_const_1 ))
            nrs[l] = nr
    return nrs

def arrangements_mset_k(mset, k):
    return arrangements_mset_max_k(mset,k)[k]

def permutations_of_combinations(mset,k):
    return sum([Permutations(comb).cardinality() for comb in Combinations(mset,k)])

def rec_calling_arrangements_mset_k(mset,k):
    mults = multiplicities(mset)
    arrs = recursive_arrangements_mset_k(mults,k)
    return arrs

def recursive_arrangements_mset_k(mults,k):
    if (k==_sage_const_0 ):
        return _sage_const_1 
    if (len(mults)==_sage_const_0 ):
        return _sage_const_0 

    arrs = _sage_const_0 
    for i in range(min(k,mults[len(mults)-_sage_const_1 ])+_sage_const_1 ):
        arrs += recursive_arrangements_mset_k(mults[:len(mults)-_sage_const_1 ], k-i)*binom_matrix[k][i]
    return arrs

def calc_binomials(k: int):
    binom_matrix=[]
    for x in range(_sage_const_0 ,k+_sage_const_1 ):
        binom = []
        for y in range(_sage_const_0 ,k+_sage_const_1 ):
            binom.append(comb(x,y))
        binom_matrix.append(binom)
    return binom_matrix

def arrangements_mult_max_k(cnt: list, k: int):
    nrs = [_sage_const_0  for _ in range(k+_sage_const_1 )]
    nrs[_sage_const_0 ]=_sage_const_1 

    for n in range(_sage_const_0 ,len(cnt)):
        for l in range(k,_sage_const_0 ,-_sage_const_1 ):
            nr = _sage_const_0 
            bino = _sage_const_1 
            for i in range(min(cnt[n],l)+_sage_const_1 ):
                nr = nr + bino*nrs[l-i]
                bino = int(bino * (l-i)/(i+_sage_const_1 ))
            nrs[l] = nr
    return nrs

def prob_xi_more_than_k(no,q,k):
    prob = _sage_const_0 
    for i in range(k,no+_sage_const_1 ):
        prob += binomial(no,i)*((_sage_const_1 /q)**i)*((_sage_const_1 -(_sage_const_1 /q))**(no-i))
    return prob

def compute_pkp_cost(mset,no,q,k):
    arrs_n = arrangements_mult_max_k(mset,no)[no]
    arrs_k = arrangements_mult_max_k(mset,floor(k/_sage_const_2 ))[floor(k/_sage_const_2 )]
    #pkp_cost = arrs_k / (sqrt(1. + ((arrs_n-1.)/(q^(no-k)))))
    pkp_cost = arrs_k / (sqrt(max(_sage_const_1 ,((arrs_n-_sage_const_1p )/(q**(no-k))))))
    return pkp_cost

def minimum_pkp_value_max_mult(max_mult,no,q,k):
    mset = []
    tot_added = _sage_const_0 
    while no-tot_added > max_mult:
        mset.append(max_mult)
        tot_added += max_mult
    mset.append(no-tot_added)
    return compute_pkp_cost(mset,no,q,k)

def minimum_pkp_value_min_d(min_d,no,q,k):
    mset = [no-min_d]
    for _ in range(min_d-_sage_const_1 ):
        mset.append(_sage_const_1 )
    return compute_pkp_cost(mset,no,q,k)

def vectors_max_mult(max_mult,no,q):
    mult = [max_mult for _ in range(q)]
    num = arrangements_mult_max_k(mult,no)[no]
    return num

def vectors_d(d,no,q):
    # Number of sequences with 3 specific faces
    vectors = _sage_const_0 
    for k in range(d):
        vectors += ((-_sage_const_1 )**(k))*binomial(d,k)*((d-k)**no) # Inclusion-Exclusion
    # Multiply for all ways of selecting those 3 faces
    vectors = binomial(q,d)*vectors
    return vectors
        

def vectors_max_d(max_d,no,q):
    if max_d <= floor(q/_sage_const_2 ):
        vectors = _sage_const_0 
        for k in range(_sage_const_1 ,max_d+_sage_const_1 ):
            vectors += vectors_d(k,no,q)
    else:
        vectors = q**no - vectors_min_d(max_d+_sage_const_1 ,no,q)
    return vectors

def vectors_min_d(min_d,no,q):
    if min_d >= ceil(q/_sage_const_2 ):
        vectors = _sage_const_0 
        for k in range(min_d,q+_sage_const_1 ):
            vectors += vectors_d(k,no,q)
    else:
        vectors = q**no - vectors_max_d(min_d-_sage_const_1 ,no,q)
    return vectors

if __name__ == '__main__':
    q = _sage_const_127 
    no = _sage_const_252 
    k = _sage_const_126 

    print("======================================")
    print("ANALYSIS BY MIN d")
    min_d = _sage_const_64 
    vec_num = vectors_min_d(min_d,no,q)
    pkp_cost = minimum_pkp_value_min_d(min_d,no,q,k)
    outside = q**no - vec_num
    print("min d:",min_d)
    print("All vectors:",n(log(q**no,_sage_const_2 )))
    print("-------------------")
    print(f"Vectors w/ min {min_d} elements:",n(log(vec_num,_sage_const_2 )))
    print("Tsample:",n(log((q**no)/vec_num,_sage_const_2 )))
    print("-------------------")
    print(f"Vectors w/ less elements:",n(log(outside,_sage_const_2 )))
    print("Tsample:",n(log((q**no)/outside,_sage_const_2 )))

